[["index.html", "Workflow Welcome", " Workflow Sara Altman, Bill Behrman, Hadley Wickham Welcome This book covers aspects of data science workflow using the tidyverse. It was developed for the Stanford Data Challenge Lab (DCL) course as a part of this curriculum. More open content from the course is available here. The book uses these packages: Package Version Source dcl 0.3.8.9000 Github (stanford-datalab/dcl) reprex 2.0.2 CRAN (R 4.3.0) tidyverse 2.0.0 CRAN (R 4.3.0) usethis 2.2.2 CRAN (R 4.3.0) The source for the book is available on GitHub where we welcome suggestions for improvements. This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["software.html", "1 Software installation 1.1 Mac computers 1.2 GitHub 1.3 Git 1.4 R 1.5 RStudio 1.6 R packages 1.7 Update R packages 1.8 Configure RStudio", " 1 Software installation Welcome to the Data Challenge Lab. Our hope is that this will be a fine learning experience for you. Please complete the steps below before our first meeting. They will prepare you to use the latest versions of Git, R, and RStudio. 1.1 Mac computers Check that you have the program Applications &gt; Utilities &gt; XQuartz. If not, or if have an older version, download from the XQuartz download site and install. Xcode command line tools Run Applications &gt; Utilities &gt; Terminal. At the prompt, enter the following command followed by a return: xcode-select --install If the command line tools are not already installed, you will be prompted with a dialog box. Click on Install. 1.2 GitHub We will be using GitHub in the DCL. If you don’t have a GitHub account: Create a free GitHub account. 1.3 Git Git is the software we will be using to access GitHub. Follow the instructions below to download and install the latest version. Note: to avoid problems, do not install any of the Git GUI clients. Mac Download from Git download site. Click on the downloaded .dmg file. Right-click on the .pkg file and select Open. Follow installation instructions to install. Windows Download from Git download site and install. Installation should include the Git Bash emulator. 1.4 R We will be using some new R packages that require the latest version of R. Follow the instructions below to download and install this version. If you already have R installed: Before installing a new version of R, save the names of your installed packages with the command saveRDS(rownames(installed.packages()), file = \"~/packages.rds\") Download the latest version of R from the R download site and install. If you already had R installed: Restart R to launch the new installed version. Check to see if you now have the same packages with if (!require(\"dplyr\")) install.packages(\"dplyr\") dplyr::setequal(rownames(installed.packages()), readRDS(\"~/packages.rds\")) If TRUE, skip to last step If FALSE, install the missing packages from CRAN with install.packages(dplyr::setdiff(readRDS(\"~/packages.rds\"), rownames(installed.packages()))) dplyr::setequal(rownames(installed.packages()), readRDS(\"~/packages.rds\")) If TRUE, skip to last step If FALSE, install the missing packages not from CRAN. You can see the ones that are still missing with dplyr::setdiff(readRDS(\"~/packages.rds\"), rownames(installed.packages())) After you have installed all the packages you previously had, you can remove the file with the names of your installed packages with unlink(\"~/packages.rds\") 1.5 RStudio If you don’t have RStudio, or don’t have the latest version: Download and install the latest version of RStudio Desktop from its download site. RStudio is constantly being updated with new features. It’s a good idea to update when RStudio indicates that a new version is available. 1.6 R packages The power of R comes from its thousands of packages, such as the tidyverse. Follow the instructions below to install some of the packages we will be using. Open up RStudio. At the R prompt in the console in the lower-left corner, install the following packages with the command install.packages(c(\"tidyverse\", \"assertthat\", \"babynames\", \"broom\", \"compare\", \"DBI\", \"dbplyr\", \"devtools\", \"fivethirtyeight\", \"flexdashboard\", \"fs\", \"ggrepel\", \"googlesheets4\", \"hexbin\", \"httr\", \"janitor\", \"jsonlite\", \"knitr\", \"leaflet\", \"nycflights13\", \"RPostgreSQL\", \"rvest\", \"scales\", \"tidycensus\", \"usethis\", \"vroom\", \"yaml\")) Here’s a description of the packages installed: tidyverse is a collection of packages, some of which we will study in depth. assertthat is for making assertions within code. babynames is a dataset of baby names. broom is for working with models. compare will be used in exercises and challenges to compare solutions. DBI is for working with databases. dbplyr is for working with databases. devtools is a set of useful R development functions. fivethirtyeight is a dataset from the 538 blog. flexdashboard is for creating dashboards. fs is for file system operations. ggrepel is for automatically positioning labels in plots. googlesheets4 is for Google Sheets data. hexbin is for plots with hexagonal bins. httr is for web APIs. janitor is for examining and manipulating data. jsonlite is for JSON data. knitr is for document generation. leaflet is for interactive maps. nycflights13 is a dataset we will be using for the early exercises. RPostgreSQL is for working with the PostgreSQL database. rvest is for web scraping. scales is for scaling functions for visualization. tidycensus is for downloading U.S. Census data. usethis is for workflow tasks such as configuring your computer. vroom is for quickly reading and writing files. yaml is for YAML data. Install the Data Challenge Lab (DCL) package. remotes::install_github(\"stanford-datalab/dcl\") Install a package with U.S. boundaries for maps remotes::install_github(\"dcl-docs/ussf\") 1.7 Update R packages Open RStudio. Hit the Packages tab in the pane in the lower-right corner, and then the Update button. Hit the Select All button, and then the Install Updates button. If you are prompted to restart your R session, select Yes. After the installations complete, your R packages will now be up to date. It’s a good idea to periodically repeat this procedure to update your packages. 1.8 Configure RStudio Carefully perform the following configuration steps: Tools (on RStudio menu bar) &gt; Global Options… General &gt; Basic Workspace Restore .RData into workspace at startup: unchecked Save workspace to .RData on exit: Never History Always save history (even when not saving .RData): unchecked Other Automatically notify me of updates to RStudio: checked General &gt; Advanced OS Integration Rendering engine: Mac: Auto-detect (recommended) Windows: Desktop OpenGL Code Editing Insert spaces for tab: checked Tab width: 2 Use native pipe operator, |&gt; (requires R 4.1+): checked Display General Show margin: checked Margin column: 80 Saving General Ensure that source files end with newline: checked Diagnostics R Diagnostics Show diagnostics for R: checked Enable diagnostics with R function calls: checked Provide R style diagnostics (e.g. whitespace): checked R Markdown Basic R Markdown Show output inline for all R Markdown documents: checked Advanced Display Show inline toolbar for R code chunks: checked "],["documentation.html", "2 Documentation", " 2 Documentation R comes with rich built-in documentation that you can access by typing ? before the name of a function. The documentation isn’t always aimed at newcomers, and may use terminology that you’re not familiar with. But don’t despair! Ignore what you don’t understand, and persevere. Often you’ll find what you need in the examples at the bottom of the help page. There are three commands in R that you should be familiar with: ?function_name opens the help for function_name(). If you know the name of the function, this will tell you how it works and how you can control its operation. (? also works for built-in datasets). If you ever wonder which package a function comes from, you can use ? to figure it out - just look at the top-left of the help page; the package name is surrounded in {}. help(package = \"package_name\") lists all the functions available in a package with links to their help pages. browseVignettes(package = \"package_name\") lists all the “vignettes” available for a package. Vignettes are longer documents that describe how multiple functions work. Many packages include an introductory vignette that give you the lay of the land: these are useful to read before you know the name of the function you need. "],["style-guide.html", "3 Style guide 3.1 Why does style matter? 3.2 Style helpers 3.3 Spacing 3.4 Pipes 3.5 Verb arguments 3.6 An indentation example", " 3 Style guide This style guide will introduce you to the style used in the Data Challenge Lab. It expands on the style introduced in the tidyverse style guide. 3.1 Why does style matter? Style guides can seem like a list of arbitrary, pointless rules, but code style does matter. Good, consistent style makes code much easier to read, helping others—including your future self—understand what a bit of code is trying to accomplish. You’ll rarely recall exactly what code does without reading it again, so think of good code style like a gift to Future You from Present You. Also, the clearer and simpler your code is, the easier it will be to identify and fix bugs. 3.2 Style helpers RStudio includes several features that will help you practice good style. These include: 80-character margin Go to Tools &gt; Global Options… &gt; Code &gt; Display, check Show Margin, and make sure that Margin column is set to 80. This turns on a line in all files that marks the 80-character cutoff. As you’ll see, you never want a line of code to exceed 80-characters. The lower lefthand corner of the RStudio editor also displays the row:column numbers. The column number gives the next position, so you’re OK if it says 81. Style diagnostics Go to Tools &gt; Global Options… &gt; Code &gt; Diagnostics and check Provide R style diagnostics. This turns on a feature that will tell you if you’ve violated some simple style rules. This tool will underline your bad code with a blue squiggle and put a blue i icon in the lefthand margin. Hover over the i to see the issue. Indentation fixer Cmd/Ctrl + I fixes some indentation issues. Highlight the code and press Cmd/Ctrl + I. 3.3 Spacing Put spaces after commas. # Bad sum(1,2) # Good sum(1, 2) Put spaces before and after mathematical operators. # Bad 1+2 # Good 1 + 2 Put spaces before and after assignment operators. # Bad df |&gt; mutate(c=a) # Good df |&gt; mutate(c = a) # Bad df&lt;-data # Good df &lt;- data 3.4 Pipes Put a space before a pipe. # Bad df|&gt; verb() # Good df |&gt; verb() Add a new line after each pipe and indent each verb. # Bad df |&gt; verb1() |&gt; verb2() # Bad df |&gt; verb1() |&gt; verb2() # Good df |&gt; verb1() |&gt; verb2() When assigning the result of a pipe to a variable, begin the pipe on a new, indented line. # Bad data &lt;- df |&gt; verb() # Bad data &lt;- df |&gt; verb() # Good data &lt;- df |&gt; verb() Avoid assigning unnecessary variables. Try to use a single pipe when possible. # Bad data1 &lt;- df |&gt; verb1() data2 &lt;- data1 |&gt; verb2() # Good data &lt;- df |&gt; verb1() |&gt; verb2() 3.5 Verb arguments Place short verb arguments on the same line as their verb. # Bad df |&gt; verb( arg = something_simple ) # Good df |&gt; verb(arg = something_simple) When changing, creating, or renaming multiple variables with mutate(), summarize(), select(), etc. put each variable on a new line. The opening parenthesis stays with the verb. The closing parenthesis gets its own line, and is aligned with the start of the verb name (Cmd/Ctrl + I will correctly do this for you). # Bad data |&gt; mutate( new_var_1 = something, new_var_2 = something ) # Bad data |&gt; mutate(new_var_1 = something, new_var_2 = something ) # Good data |&gt; mutate( new_var_1 = something, new_var_2 = something ) Code should never extend beyond the 80-characters line. Sometimes, all you’ll need to do is put the function argument on a new line and indent. Again, make sure that the first parenthesis stays with the verb, and the second is on its own line and is aligned with the verb name. # Bad data |&gt; verb(very_long_argument_name_1 = something_so_complicated_it_goes_past_the_line) # Bad data |&gt; verb( very_long_argument_name_1 = something_so_complicated_it_goes_past_the_line) # Bad data |&gt; verb( very_long_argument_name_1 = something_so_complicated_it_goes_past_the_line ) # Good data |&gt; verb( very_long_argument_name_1 = something_so_complicated_it_goes_past_the_line ) If the verb has multiple arguments and those arguments exceed 80 characters, put each argument on its own line. # Bad data |&gt; verb(very_long_argument_name_1 = something_complicated_1, very_long_argument_name_2 = something_complicated_2) # Bad data |&gt; verb( very_long_argument_name_1 = something_complicated_1, very_long_argument_name_2 = something_complicated_2 ) # Good data |&gt; verb( very_long_argument_name_1 = something_complicated_1, very_long_argument_name_2 = something_complicated_2 ) Sometimes, just putting the arguments on their own lines won’t solve the length problem. In these cases, a more complicated indenting scheme is required. In the next section, we’ll walk through this scheme in more detail. For now, here are some examples. # Bad data |&gt; mutate(var = complicated_fun(arg1 = &quot;something&quot;, arg2 = &quot;something else&quot;, arg3 = &quot;another thing&quot;)) # Good data |&gt; mutate( var = complicated_fun( arg1 = &quot;something&quot;, arg2 = &quot;something else&quot;, arg3 = &quot;another thing&quot; ) ) # Bad df |&gt; ggplot(mapping = aes(x = a_long_variable_name, y = another_long_variable_name, fill = a_third_long_variable_name), position = &quot;dodge&quot;) + geom_col() # Good df |&gt; ggplot( mapping = aes( x = a_long_variable_name, y = another_long_variable_name, fill = a_third_long_variable_name ), position = &quot;dodge&quot; ) + geom_col() 3.6 An indentation example The indentation scheme introduced above can be confusing. Here, we’ll walk through an example so you can it in action. # Bad data |&gt; mutate(var = complicated_fun(arg1 = &quot;something&quot;, arg2 = &quot;something else&quot;, arg3 = &quot;another thing&quot;)) Step 1 Put the contents of the verb on its own line. data |&gt; mutate( var = complicated_fun(arg1 = &quot;something&quot;, arg2 = &quot;something else&quot;, arg3 = &quot;another thing&quot;) ) If none of the code goes over the 80-character line, you’re done! In this case, the code still exceeds 80 characters, so we’ll need to proceed to Step 2. Step 2 Add a newline after the “=”. data |&gt; mutate( var = complicated_fun(arg1 = &quot;something&quot;, arg2 = &quot;something else&quot;, arg3 = &quot;another thing&quot;) ) Again, if none of the code goes over the line, you’re done. Our code still surpasses 80-characters, so we’ll head to Step 3. Step 3 Give each function argument its own line. data |&gt; mutate( var = complicated_fun( arg1 = &quot;something&quot;, arg2 = &quot;something else&quot;, arg3 = &quot;another thing&quot; ) ) Now, everything is under 80 characters and the code is easy to read. There are also situations where you’ll want to put each function argument on its own line even if the code doesn’t extend past 80 characters. functions that should usually have each argument on its own line include if_else(), recode(), and case_when(). # Not great data |&gt; mutate( var = recode(v1 = &quot;something&quot;, v2 = &quot;something else&quot;, v3 = &quot;another thing&quot;) ) # Better data |&gt; mutate( var = recode( v1 = &quot;something&quot;, v2 = &quot;something else&quot;, v3 = &quot;another thing&quot; ) ) Remember to line up the closing parenthesis with the start of the function name. You can always check your indenting by highlighting the code and doing Cmd/Ctrl + I. "],["rstudio-snippets.html", "4 RStudio code snippets 4.1 tv snippet 4.2 rscript snippet", " 4 RStudio code snippets In RStudio, code snippets are text macros that you can use to insert bits of commonly used code. Here, we’ll walk you through the creation of two snippets: A snippet to add in library(tidyverse) A snippet to start an R script You can use the same process to create any snippet you want. 4.1 tv snippet Go to Tools &gt; Global Options… &gt; Code, and find the Snippets section. Make sure Enable code snippets is checked. Click on Edit Snippets…. Scroll down to the bottom of the snippet editor to add your snippet. Paste in the following code to create a library(tidyverse) snippet named tv: snippet tv library(tidyverse) Note that every line after snippet [snippet name] must start with a single tab. Click Save and exit the Preferences window. Now, you can use your snippet. In the console, an RMarkdown document, or an R script, type tv then hit tab. library(tidyverse) should appear. 4.2 rscript snippet We used a script template to create the scripts in our example project. Each script has a section for parameters and a section for code, separated by a line. There are spots for the description, author, and version. Here’s what the script template looks like: # Description # Author: Name # Version: 2021-09-08 # Packages library(tidyverse) # Parameters #=============================================================================== # Code Because the script template has elements for the user to fill in, the rscript snippet is going to be more complicated than the tv snippet. Follow the steps from the previous section to open the snippet editor. Paste in the following code to create a snippet named rscript: snippet rscript # ${1:Description} # Author: ${2:Name} # Version: `r Sys.Date()` # Packages library(tidyverse) # Parameters # ============================================================================ ${3:# Code} The ${} components create variables. As you’ll see later, when you use the snippet, you can tab through these variables to fill them in. The numbers inside the {}s define the order in which you can tab through them. Click Save and exit the Preferences window. Now, you can use your snippet. Type rscript and then hit tab. The script template should appear. Fill in your variables (if the snippet has any). You can tab to automatically move the cursor to the next variable. You shouldn’t have to type out rscript everytime you want to use the snippet. If you type out a portion of rscript, the name of the snippet should appear and you can hit tab to select the snippet. "],["project-introduction.html", "5 Project introduction", " 5 Project introduction Good project workflow habits can make your data life calmer and easier, save you from preventable errors, and help you more effectively explore and analyze data. In this section, we’ll present our approach to project workflow. We’ll start by explaining how to setup a project and connect it to GitHub. Then, we’ll go over how to organize files and keep everything up to date. We’ll also explain how to effectively use R scripts. "],["project-setup.html", "6 Project setup 6.1 Create a project 6.2 Setup GitHub", " 6 Project setup 6.1 Create a project We recommend creating one directory for each project. All your data and files for your project will live in this one directory. Ideally, you’ll organize your files in this directory in a principled way. We’ve created a project template with our suggested folder organization. If you haven’t already, install the dcl package: # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;stanford-datalab/dcl&quot;) Now, you can run dcl::create_data_project(path = &quot;PATH/TO/PROJECT&quot;) to create a directory at your supplied path with the following files and directories: data: cleaned data data-raw: raw data docs: data documentation and notes eda: exploratory data analysis on your cleaned data scripts: data manipulation scripts reports: findings to present to others Makefile .gitignore README.md We’ll discuss how to use these directories and files in the next chapter. By default, dcl::create_data_project() creates an RStudio project for the directory. If you don’t want to create an RStudio project, set the project argument to FALSE: dcl::create_data_project(path = &quot;PATH/TO/PROJECT&quot;, project = FALSE) Note that it’s generally a bad idea to nest RStudio projects. If you find yourself wanting to use our folder organization inside a different RStudio project, you’ll probably want project = FALSE. 6.2 Setup GitHub We recommend using GitHub for all your data work. Generally, you’ll want one repository per project. Here, we’ll explain how to setup Git and GitHub for your new project. The following steps will only work if you set project = TRUE in the previous section (they require a .Rproj file). However, if you didn’t want an RStudio project for your project, you likely also don’t want a GitHub repository. 6.2.1 GitHub token You will need a GitHub personal access token in order to setup Git and GitHub from RStudio. Open GitHub in your browser. Then: Click on your profile picture in the upper righthand corner, then click on Settings. Then, go to Developer settings &gt; Personal access tokens &gt; Tokens (classic). Click Generate new token. Name your token something like RStudio or R. Under Scopes, select repo (You can select other scopes if you anticipate using the GitHub API in more scenarios.) Scroll down to the bottom, then click Generate token. Copy the resulting token to your clipboard and return to RStudio. From the RStudio console, open your .Renviron file with usethis::edit_r_environ() Add the following line to your .Renviron file, replacing YOUR_TOKEN with the token you copied earlier. GITHUB_PAT=YOUR_TOKEN Save the file. Restart R (Cmd/Ctrl + Shift + 0). 6.2.2 use_git() Now, we can create a Git repository for your project. If you haven’t already, open your project in RStudio. Then, in the console, run usethis::use_git() use_git() will set up a Git repository for your project, then ask you if you want to make an initial commit: Enter the number that corresponds to the Yes option. Here, that’s 3, but it might be different for you. Next, you’ll be prompted to restart RStudio. Select the Yes option. 6.2.3 use_github() use_git() initializes a Git repository, but you’ll still need to connect that repository to GitHub. To do so, run usethis::use_github() Note that use_github() has multiple optional arguments that allow you to, for example, create the repository under an organization or make the repository private. You’ll be prompted for a git protocol. You’ll probably want ssh. Next, you’ll be prompted to verify the repository name and description. Say Yes unless you’re unhappy with them (you can always change them later). You might get the following error: If so, copy the recommended command. git push --set-upstream origin master Then, open Terminal, navigate to your project directory, paste in your copied command, and press enter. This command sets the default location to which git push will push. Earlier, use_github() opened your GitHub repository in the browser. To see the result of your push, refresh the page. Your files should appear. Your setup is complete! In the next chapter, we’ll go into more detail about how to use the folders and makefile created by dcl::create_data_project(). "],["project-organization.html", "7 Project organization 7.1 Directories 7.2 File paths 7.3 R Markdown template 7.4 Make", " 7 Project organization In this chapter, we’ll talk about how to organize your project. We’ll discuss how to use the project template created by dcl::dcl_data_project(), explain an easier way to handle file paths, and walk you through the creation of a makefile. 7.1 Directories Here’s an overview of the relationships between the various directories created by dcl::dcl_data_project(): To help explain the different directories, we’ll refer to our project example, which uses data on migratory birds’ collisions with lighted buildings in Chicago. 7.1.1 data-raw Put all raw data files (i.e., the data that you haven’t touched yet) in data-raw. For each data file, come up with a short, but descriptive, name. You’ll use these names to name other files. For example, our example data-raw contains the following raw data files: birds.txt collisions.csv light_mp.csv 7.1.2 scripts Data-manipulation scripts belong in scripts. We’ll talk more about R scripts in the next chapter, but you can also take a look at our example scripts. Create one script for each raw data source. Each script should read in a raw data file, process it, and then write the cleaned data to an .rds file in data. Name each script to correspond to the data file it creates. For example, the script collisions.R reads in collisions.csv, cleans the data, then writes collisions.rds to data. If you want to join multiple data sources, create an additional script that joins the cleaned data files. For example, bird_collisions_light.R joins birds.rds, collisions.rds, and light_mp.rds, and writes to bird_collisions_light.rds. As the diagram points out, your joining scripts can join cleaned data from data. 7.1.3 data data contains cleaned data (likely in .rds format) that is ready to analyze. The name of each .rds file should correspond to the script that created it. For example: collisions.rds birds.rds light_mp.rds bird_collisions_light.rds 7.1.4 docs The docs folder is for any documentation files you used to understand the data, as well as for any notes you have on the data or your plan for analysis. 7.1.5 eda The eda folder contains R Markdown files with your exploratory data analysis (EDA) work. As a start, perform EDA on each dataset and name the R Markdown files accordingly. For example, birds.Rmd performs EDA on just birds.rds, bird_collisions_light.Rmd performs EDA on just bird_collisions_light.rds, etc. Once you understand your data, you can perform further EDA studies, each in an R Markdown file with a descriptive name. This separation is intended to help you organize your EDA, which can become unwieldy if placed in a single file. 7.1.6 reports reports is for your final reports, shareable analysis, etc. The files here don’t need to be named according to the convention of the other files. For example, our reports folder just has one report called report.Rmd. 7.2 File paths The here package simplifies the work of specifying file paths. The function here::here() allows you to specify a file path relative to the directory of your .Rproj file, no matter what folder you’re in. For example, no matter where you are in your project, you can give the file path of collisions.rds as here::here(\"data/collisions.rds\"). See the our scripts, EDA documents, and reports for more examples. 7.3 R Markdown template The dcl package also contains a R Markdown template to use for your EDA files and reports. To use the template: Click on the new file button in the top-left corner of RStudio. Select R Markdown… &gt; From Template &gt; DCL GitHub Document. Our template is similar to the default GitHub document template, but: Includes a table of contents by default. Formats the first R chunk to highlight places for packages, parameters, and reading in code. Has example headers. 7.4 Make Imagine that birds.txt, our example raw data set, gets updated. Maybe the original owners added new birds or corrected a mistake. The cleaned birds data, birds.rds, depends on birds.txt, as do other data files, EDA documents, and reports. To update all these files, we could rerun all our scripts, then re-knit all our EDA files and reports. However, manually updating all our files can get tedious. It also requires remembering which files depend on each other, which can get complicated. Makefiles are a better way to update files and keep track of dependencies. A program called Make reads your makefile, looks for changes in the files specifies, then rebuilds all files that depend on the ones that changed. GNU Make is free software and comes installed on Macs and most Unix machines. If you’re a Windows user, you might need to install Make yourself. 7.4.1 Create a makefile dcl::create_data_project() creates a makefile template for you, but you’ll still need to fill in the details. We’ll use our makefile from the birds project as an example. Note that this section will be most informative if you have our makefile template in front of you and are ready to fill it in. If you want to learn more about makefiles, the GNU Make manual is a good reference. 7.4.1.1 Search path Find the line that says VPATH = Add in the names of all the folders where Make should look for your files. This will probably be: VPATH = data data-raw eda reports scripts 7.4.1.2 Targets all : $(DATA) $(EDA) $(REPORTS) on line 14 defines a target called all. This tells Make to, by default, consider all the files defined by DATA, EDA, and REPORTS. For this to work, you’ll need to fill in the variables DATA, EDA, and REPORTS on lines 5-11 with the names of your files. For example, ours has # Processed data files DATA = birds.rds collisions.rds light_mp.rds bird_collisions_light.rds # EDA studies EDA = birds.md collisions.md light_mp.md bird_collisions_light.md # Reports REPORTS = report.md 7.4.1.3 Dependencies Now, you need to specify the dependencies of your project. File A depends on File B if changing File B can change File A. For example, birds.md depends on birds.rds because changing the cleaned data in birds.rds could change the analysis, visualizations, etc. in birds.md. Underneath the comment that says, # Data dependencies, you’ll specify which how the cleaned data (the .rds files) depend on the raw data. For example, here’s what we have in our birds makefile: birds.rds : birds.txt collisions.rds : collisions.csv light_mp.rds : light_mp.csv bird_collisions_light.rds : birds.rds collisions.rds light_mp.rds The syntax is: [target file] : [dependency file 1] [dependency file 2] [dependency file 3] Next, underneath the comment that says # EDA study and report dependencies, specify how your knitted reports (your .md files) depend on the cleaned data. birds.md : birds.rds collisions.md : collisions.rds light_mp.md : light_mp.rds bird_collisions_light.md : bird_collisions_light.rds report.md : bird_collisions_light.rds Your files can have any number of dependencies, but make sure to separate the dependencies with a single space. If you need more than one line for your dependencies, end all lines except the last with a “\\” . 7.4.1.4 Rules Finally, Make needs to know how to update different types of files. We want Make to run a script if raw data changes, but knit an R Markdown document if cleaned data changes. Lines 30-33 define our rules. You probably won’t need to update these rules, but it’s useful to understand them. The first rule (lines 30-31) tells Make how to update a .rds file. For example, say birds.txt changes. Make knows that birds.rds depends on birds.txt because of our specified dependencies. Make then looks to our first rule to figure out how to update birds.rds. The rule says to run the R script with the same name as the .rds file. In our example, that script is birds.R, so Make will run birds.R. The second rule (32-33) tells Make how to update a .md file. The rule tells Make to knit the .Rmd version of the relevant .md file. For example, if birds.md needs updating (because birds.rds changed), Make will knit birds.Rmd. 7.4.2 Run Make Once you’ve set up your makefile (and have the necessary files in place), navigate to your project directory from the command line. Then, type make and hit enter. Your scripts should run and your files should knit. After make is done, try running make again. You’ll get a message saying make: Nothing to be done for 'all'. because nothing has changed since the last time Make ran. Now, you can run make from the command line every time you want to rebuild your project, suspect something has changed, or have resumed work again. Your files will automatically be kept up to date. "],["scripts.html", "8 Scripts", " 8 Scripts If you’re coming from the world of R Markdown, you can think of an R script like one long code chunk. R scripts are useful if you don’t need the hybrid between text and code offered by R Markdown. Often, this happens when you’re reading in and cleaning data. We’ve designed a short R script template to help create organized scripts. If you haven’t already, create a snippet for the template by following the steps in Chapter 4. If you’re a DCL student, you likely did this in the first week of class. You can open a new R script by clicking on the new file button in the upper-left corner of RStudio, then on R Script. Note that R Scripts have the file extension .R. Once in the R script, start typing rscript (the name of the snippet), then hit tab. Your script should now have the following template code: # Description # Author: Name # Version: 2023-08-08 # Packages library(tidyverse) # Parameters #=============================================================================== # Code This is our script template. Replace Description with a brief description of the script and Name with your name. All parameters go in the parameters section, between # Parameters and the line of ===. All code goes below the ===. The point of this division is to clearly separate parameters, which might change later on, from code. Make parameters for features that are contingent (e.g., the year you’re using to filter your data), especially if you use that feature in multiple locations throughout your script. Then, add your code. As mentioned earlier, a common use for R scripts is reading in and writing out data. Here’s the code from an example script that does exactly that. # Transforms species data on light by date at McCormick Place in Chicago # Source: # Winger BM, Weeks BC, Farnsworth A, Jones AW, Hennen M, Willard DE (2019) # Data from: Nocturnal flight-calling behavior predicts vulnerability to # artificial light in migratory birds. Dryad Digital Repository. # https://doi.org/10.5061/dryad.8rr0498 # Authors: Sara Altman, Bill Behrman # Version: 2023-08-08 # Packages library(tidyverse) # Parameters # Input file file_raw &lt;- here::here(&quot;data-raw/light_mp.csv&quot;) # Output file file_out &lt;- here::here(&quot;data/light_mp.rds&quot;) #=============================================================================== file_raw |&gt; read_csv( col_types = cols(Date = col_date(), Light_Score = col_double()) ) |&gt; rename_with(str_to_lower) |&gt; drop_na() |&gt; group_by(date) |&gt; summarize(light_score = round(mean(light_score))) |&gt; write_rds(file_out) This script reads in data from file_raw, does some light manipulation, and then writes out the files to file_out. You can run your whole script by clicking Source in the upper-right corner, but you can also run R script code with all the same keyboard shortcuts you use to run code in R Markdown chunks. You can also run your script from the command line. Open Terminal, navigate to your script’s directory, then run Rscript PATH_TO_YOUR_SCRIPT This is useful if you’re working with a lot of data and care about speed, because you can run your script without dealing with any overhead caused by RStudio. "],["getting-help.html", "9 Getting help 9.1 Help yourself 9.2 Get help from others", " 9 Getting help 9.1 Help yourself Carefully read the error message. Often it won’t help, but sometimes there are hints that will help you get started. If you encounter an error message you don’t understand, strip anything highly specific (like your object or variable names), surround it with quotes and Google it! (If the error message isn’t in English, run Sys.setenv(LANGUAGE = \"en\") and re-run the code; you’re more likely to find help for English error messages.) Search the tidyverse community. If you can’t find an answer, you can pose a question using a reprex as explained below. 9.2 Get help from others If someone has the wit and knowledge to answer your question, they probably have other things they would like to do. Making your message clear, concise and user-friendly gives you the best hope of at least one of those strangers diverting their attention away from their life towards your problem. — The 9th circle of The R Inferno If you need help getting unstuck, the first step is to create a reprex, or reproducible example. The goal of a reprex is to package your problematic code in such a way that other people can run it and feel your pain. Then, hopefully, they can provide a solution and put you out of your misery. There are two parts to creating a reprex: First, you need to make your code reproducible. This means that you need to capture everything, i.e., include any library() calls and create all necessary objects. The easiest way to make sure you’ve done this is to use the reprex package (see below). Second, you need to make it minimal. Strip away everything that is not directly related to your problem until removing any remaining code will either remove your problem or cause a new error. This usually involves creating a much smaller and simpler R object than the one you’re facing in real life or even using built-in data. That sounds like a lot of work! And it can be, but it has a great payoff: 80% of the time creating an excellent reprex reveals the source of your problem. It’s amazing how often the process of writing up a self-contained and minimal example allows you to answer your own question. The other 20% of time you will have captured the essence of your problem in a way that is easy for others to play with. This substantially improves your chances of getting help! 9.2.1 The reprex package When creating a reprex by hand, it’s easy to accidentally miss something that means your code can’t be run on someone else’s computer. Avoid this problem by using the reprex package. It’s installed as part of the tidyverse. Go ahead and load it. library(reprex) Write a bit of code and copy it to the clipboard: y &lt;- 1:4 y mean(y) Enter reprex() in the R Console. In RStudio, you’ll see a preview of your rendered reprex. y &lt;- 1:4 y #&gt; [1] 1 2 3 4 mean(y) #&gt; [1] 2.5 It is now ready and waiting on your clipboard, so you can paste it into, say, a GitHub issue. If your code creates an image, reprex will create the image and embed a link to it. If your code is not self-contained, running reprex() results in an error. It may feel like tough love, but this way you can get your story straight in private. The reprex format also strongly encourages you to find the minimal dataset necessary to show your problem. Creating an effective reprex is a learned skill and the immediate feedback from reprex makes this very concrete. 9.2.2 More resources on asking good questions How To Ask Questions The Smart Way, Eric Raymond and Rick Moen. You’ll need a slightly thick skin, but they speak truth. How to Ask for Programming Help How do I ask a good question?, Stack Exchange What have you tried?, Matt Gemmell. "],["learning-more.html", "10 Learning more", " 10 Learning more The DCL curriculum covers the basics of data science in R, but there’s still a lot to learn! To keep learning, it’s good to build up a regular practice to keep up to date. Here are some useful resources: tidyverse.org: An up-to-date resource for everything tidyverse. tidyverse.org blog: Articles and descriptions of new package releases. R Weekly: A weekly newsletter highlighting what’s been happening in the R community. Hadley’s Twitter feed "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
